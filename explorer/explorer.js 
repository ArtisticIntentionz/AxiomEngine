document.addEventListener('DOMContentLoaded', () => {
    const searchButton = document.getElementById('searchButton');
    const nodeIdInput = document.getElementById('nodeIdInput');
    const dashboard = document.getElementById('dashboard');
    const errorMessage = document.getElementById('errorMessage');

    // In a real app, you would ask the user for a node API URL.
    // For this demo, we'll assume we're querying the local node at port 8001.
    const API_BASE_URL = 'http://127.0.0.1:8001'; 

    let ledgerChart = null;

    const fetchData = async (endpoint) => {
        try {
            const response = await fetch(`${API_BASE_URL}${endpoint}`);
            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error(`Failed to fetch ${endpoint}:`, error);
            errorMessage.textContent = `Error: Could not connect to the Axiom node at ${API_BASE_URL}. Is it running?`;
            return null;
        }
    };

    const searchNode = async () => {
        const nodeId = nodeIdInput.value.trim();
        if (!nodeId) {
            errorMessage.textContent = 'Please enter a Node Public Key.';
            return;
        }
        
        // In a real decentralized explorer, you would query a known node
        // and ask IT for the stats of the requested `nodeId`.
        // For simplicity here, we assume we are querying the node itself.
        // This is a placeholder for that more complex logic.
        // We'll just fetch stats from our connected node for the demo.
        
        errorMessage.textContent = '';
        dashboard.style.display = 'block';

        // Fetch all data in parallel
        const [nodeStats, networkStats, growthData] = await Promise.all([
            fetchData('/explorer/node_stats'),
            fetchData('/explorer/network_stats'),
            fetchData('/explorer/ledger_growth')
        ]);

        if (nodeStats) updateNodeStats(nodeStats);
        if (networkStats) updateNetworkStats(networkStats);
        if (growthData) updateLedgerChart(growthData);
    };

    const createStatCard = (title, value, unit = '', className = '') => {
        return `
            <div class="stat-card ${className}">
                <h3>${title}</h3>
                <div class="value">${value} <span style="font-size: 0.5em;">${unit}</span></div>
            </div>
        `;
    };

    const updateNodeStats = (stats) => {
        const grid = document.getElementById('nodeStatsGrid');
        document.getElementById('nodeHeader').textContent = `Node Performance: ${stats.public_key.substring(0, 16)}...`;
        
        let content = createStatCard('Reputation Score', stats.reputation_score.toFixed(7), '', 'reputation border');
        content += createStatCard('Rewards Earned', stats.rewards_earned, 'AXIOM');
        content += createStatCard('Blocks Proposed', stats.blocks_proposed);
        content += createStatCard('Uptime', `${stats.uptime_percentage}%`);
        content += createStatCard('Stake Amount', stats.stake_amount, 'AXIOM');
        content += createStatCard('Region', stats.region);
        
        grid.innerHTML = content;
    };

    const updateNetworkStats = (stats) => {
        const grid = document.getElementById('networkStatsGrid');
        
        let content = createStatCard('Current Block Height', stats.current_block_height);
        content += createStatCard('Total Facts Grounded', stats.total_facts_grounded);
        content += createStatCard('Corroborated Facts', stats.corroborated_facts, '', 'reputation border');
        content += createStatCard('Disputed Facts', stats.disputed_facts, '', 'disputed border');
        content += createStatCard('Active Validators', stats.active_validators);

        grid.innerHTML = content;
    };

    const updateLedgerChart = (data) => {
        const ctx = document.getElementById('ledgerGrowthChart').getContext('2d');
        
        const labels = data.map(d => `Block ${d.height}`);
        const factData = data.map(d => d.total_facts);

        if (ledgerChart) {
            ledgerChart.destroy();
        }

        ledgerChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Total Facts in Ledger',
                    data: factData,
                    borderColor: 'rgba(0, 123, 255, 1)',
                    backgroundColor: 'rgba(0, 123, 255, 0.2)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Number of Facts' }
                    },
                    x: {
                        title: { display: true, text: 'Block Height' }
                    }
                }
            }
        });
    };

    searchButton.addEventListener('click', searchNode);
    nodeIdInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            searchNode();
        }
    });
});