# Axiom - merkle.py
# Copyright (C) 2025 The Axiom Contributors
# This program is licensed under the Peer Production License (PPL).
# See the LICENSE file for full details.
"""A Merkle Tree engine for generating cryptographic proofs."""

from __future__ import annotations

import hashlib


def _hash_pair(left: bytes, right: bytes) -> bytes:
    """Combine and hash two byte strings using SHA-256."""
    return hashlib.sha256(left + right).digest()


class MerkleTree:
    """A cryptographic tool for creating verifiable proofs of inclusion.

    This class provides the trustless bridge between Sealer and Listener nodes,
    allowing a lightweight client to verify data from a full node with
    mathematical certainty.
    """

    def __init__(self, data: list[str]) -> None:
        """Initialize the MerkleTree and build it from the provided data.

        Args:
            data: A list of strings to be included as leaves in the tree.

        Raises:
            ValueError: If the data list is empty.

        """
        if not data:
            raise ValueError("Cannot create a Merkle Tree with no data.")

        # 1. Prepare the leaves: Convert all string data to bytes and hash them.
        self.leaves: list[bytes] = [
            hashlib.sha256(item.encode()).digest() for item in data
        ]

        # 2. Pad the leaves to ensure an even number for pairing.
        if len(self.leaves) % 2 == 1:
            self.leaves.append(self.leaves[-1])

        # 3. Build the tree level by level.
        self.levels: list[list[bytes]] = [self.leaves]
        while len(self.levels[-1]) > 1:
            self._build_next_level()

        self.root: bytes = self.levels[-1][0]

    def _build_next_level(self) -> None:
        """Take the last level of the tree and build the next level up."""
        last_level = self.levels[-1]
        next_level: list[bytes] = []
        # Take pairs of nodes from the last level and hash them.
        for i in range(0, len(last_level), 2):
            left = last_level[i]
            right = last_level[i + 1]
            next_level.append(_hash_pair(left, right))

        # If the new level is odd, pad it.
        if len(next_level) % 2 == 1 and len(next_level) > 1:
            next_level.append(next_level[-1])

        self.levels.append(next_level)

    def get_proof(self, index: int) -> list[tuple[bytes, str]]:
        """Generate the proof of inclusion for a leaf at a given index.

        Args:
            index: The index of the leaf for which to generate the proof.

        Returns:
            A list of tuples, where each tuple contains a sibling hash and its
            position ("left" or "right"), representing the path to the root.

        Raises:
            IndexError: If the leaf index is out of range.

        """
        if index < 0 or index >= len(self.leaves):
            raise IndexError("Leaf index out of range.")

        proof: list[tuple[bytes, str]] = []
        for level in self.levels[:-1]:  # Iterate from the bottom up
            # Determine if the node at the current index is a left or right child
            is_right_node = index % 2 == 1
            sibling_index = index - 1 if is_right_node else index + 1

            # The proof consists of the sibling node and its position
            proof.append(
                (level[sibling_index], "left" if is_right_node else "right"),
            )

            # Move up to the parent node for the next level
            index //= 2

        return proof

    @staticmethod
    def verify_proof(
        proof: list[tuple[bytes, str]],
        leaf_data: str,
        root: bytes,
    ) -> bool:
        """Verify a proof without needing the entire tree.

        This static method is the core of trustless verification for Listeners.

        Args:
            proof: The proof generated by the `get_proof` method.
            leaf_data: The original, unhashed data of the leaf to verify.
            root: The trusted Merkle root hash from the block header.

        Returns:
            True if the proof is valid, False otherwise.

        """
        # Start with the hash of the data we are trying to prove.
        current_hash = hashlib.sha256(leaf_data.encode()).digest()

        # Iteratively climb the tree using the proof's sibling hashes.
        for sibling_hash, position in proof:
            if position == "left":
                current_hash = _hash_pair(sibling_hash, current_hash)
            else:
                current_hash = _hash_pair(current_hash, sibling_hash)

        # If the final calculated hash matches the trusted root, the proof is valid.
        return current_hash == root
